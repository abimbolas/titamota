# Архитектура приложения

Это бэкенд и фронтенд часть.

Бэкенд хранит базу данных, авторизует, выдаёт фильтрованные так или иначе записи, ну и как обычно. На Django + Postgres + Gunicorn + Nginx.

Фронтенд же на Vue + Vuex.

**Фронтенд**

Узловая точка фронта - сервис апи, общающися с бэкендом. Бекенд у нас может быть локальным (локалсторадж), то есть два разных. Поэтому это дело реализовано по паттерну абстрактного класса и его имплементаций (драйверов). Джанго бекенд это одна реализация этого абстрактного класса, а локалсторадж-бекенд другая. Только сделано не прям на классах с наследованием, а просто объектами-классами подставляется в нужный момент. Главное что апи одно и тоже а дальше не лезем, там драйвер всё сделает.

Так вот, а к апи этому обращается... команда из паттерна команды+стейт+подписка, реализовано с помощью vuex-аддона к фреймворку vue. Есть стейт приложения, единый. Его можно читать но нельзя изменять напрямую. Изменять можно с помощью команд, в терминах vuex - мутаций - спецобъектов. Плюс есть "действия" (или акты), это тоже как мутация, но только асинхронная и подразумевается что выполняет сложные действия, в том числе запускает другие мутации. А сами мутации всегда простейшие и меняют что-то одно.

Так вот, всё общение и происходящее в таймере происходит с помощью вот этих действий и мутаций, в том числе и обращение к узловому апи. На самом деле почти всё общение с сервером (кроме миграции и экспорт-импорта) проходит через один модуль стейта и его 4х действий-актов. Там просто помимо вызова апи ещё парочка мутаций и специфических штуковин делается, например контекст задача оборачиваетя-разворачивается.

Ну и дальше это собственно компоненты визуальные - таймер, строки, задачки, виды, пункты меню, сайдбар и его настройки, кнопки авторизации и вот это всё. Эти компоненты имеют доступ к мутациям и могут подписываться на них (чтоб реагировать как-то).

Вот этим всем - апи + стейт с командами + компоненты и грубо описывается весь таймер. Помимо этого только остаётся обслуживающая хрень - директивы там, утилиты-функции вспомогательные, а, ну и  модели-классы данных (запись, дерево и т.д.) и всякое такое.

Модели возможно поподробнее, но возможно не сейчас.

Следующая важная штука - это специфика построения данных.

## Специфика построения данных

Дело в том что я не храню деревья и прочее - только список исходных записей времени, каждая из которых (не храню на бэкенде в смысле) состоит только из старта, стопа (время) и ... массива строк, называемого "детали". В этих деталях и записываются подробности будущей структуры. Подразумевалось что она может быть любая и уже на уровне плагинов представления я буду по-разному интерпретировать этот массив.

Но пока всё удачно свелось только к дереву (хотя планируется теги ввести). Короче - фронтенд на лету из массива полученных записей в каждый момент времени генерит и поддерживает несколько представлений-группировок - во-первых просто дерево задач. дерево формируется из деталей записей, это как будто путь к файлу через папки. [project, task] и [project, task2] дадут дерево из узла project который имеет два под-узла task и task2 - ну наверно знакомая концепция "расплющивания" дерева в список. Так вот, группировка в дерево беря детали задачи как путь к узлу, затем отдельно - группировка по месяцам, по дням, по годам, а внутри каждого периода - опять по задачам-деревьям. На самом деле можно и сложней группировать, но просто не нужно, но архитектурно можно расширить. Пока это две сквозные классификации - дерево задач и дата. Если будут теги, то это третий признак классификации, будет сложней, но пока так.

Ну и просто вид как есть, список всех записей как они есть (хранилище)

Так вот, вот это важно сразу просечь - что как таковых папок и проектов нету, это строится только виртуально на лету пока ты сидишь в сервисе. Поэтому это и гибко может быть, но несоклько может запутывать. Поэтому часть мутаций и команд идет на то, чтобы поддерживать деревья в состоянии нужном, но благо это делается только в одном месте и сносно работает, через плагины к vuex. Ну последнее, например - у записи есть айди, а у проекта нет - это просто временная группировка. Поэтому так легко менять структуры - просто переименовать группу задач (а интерфейс так и построен) и вот он уже в "новой папке", оно перестроило свою соотв. ветку на лету. И, напоминаю - одновременно, даже если не видно, есть все эти деревья - сформированные из одного исходного набора. То есть таким образом - мы видим разные представления визуальные одного и того же набора исходных записей. один источник правды и ряд интерпретаций и представлений (который предполагается расширять) - месяцы, дни, дерево задач и т.д. - как-то так.

Собственно все остальное, паджинация, контекст - сделаны через это. В том смысле что я сначала фильтруя, прошу сервер определённый набор записей, а фронтенд из этого уже строит все структуры. Я прошу всё записи за месяц и фронт строит дерево за месяц. Таким образом получается что никаких манипуляций с деревьями и перегруппировками по сути не происходит.

Ну, заканчиваю и так по кругу.

Дальше уже конкретные области в глубину, нужны вопросы.
